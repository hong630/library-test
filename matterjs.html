<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>metter.js 테스트</title>
  <link rel="stylesheet" href="assets/css/style.css">
  <link rel="stylesheet" href="assets/css/matter.css">
</head>
<body>
<div class="big-wrapper">
  <div class="wrap">
    <div id="score">0</div>
    <div class="tip">
      <span class="tip-text">탭하면 공 생성 · 같은 크기끼리 합쳐지면 더 큰 공!</span>
      <span class="next-wrap" aria-label="다음 공"><span class="next-label">NEXT</span><img id="nextBallImg" alt="다음 공" /></span>
    </div>
    <div class="canvas-container">
      <canvas id="game"></canvas>
    </div>
    <div id="gameover" class="modal hidden" role="dialog" aria-modal="true">
      <div class="modal-box">
        <p class="modal-title">GAME OVER</p>
        <p class="modal-sub">score: <span id="finalScore">0</span></p>
        <button id="restartBtn" class="modal-btn">다시 시작!</button>
      </div>
    </div>
</div>


</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
  const {Engine,Render,Runner,World,Bodies,Events} = Matter;

  const engine = Engine.create();
  engine.world.gravity.y = 1;
  engine.positionIterations = 10;
  engine.velocityIterations = 8;

  const container = document.querySelector('.canvas-container');
  const W = Math.floor(container.clientWidth);
  const H = Math.floor(container.clientHeight);
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  const render = Render.create({
    canvas: document.getElementById('game'),
    engine,
    options:{ width: W, height: H, wireframes:false, background:'transparent' }
  });
  Render.setPixelRatio(render, dpr);

  addEventListener('resize', () => location.reload());

  // 벽/바닥
  const groundMargin = 70;
  const groundThickness = 60;
  World.add(engine.world, [
    Bodies.rectangle(
            W/2,
            H - groundMargin + (groundThickness / 2),
            W + 200,
            groundThickness,
            { isStatic: true }
    ),
    Bodies.rectangle(-30, (H - groundMargin) / 2, 60, H + 200, {isStatic:true}),
    Bodies.rectangle(W+30, (H - groundMargin) / 2, 60, H + 200, {isStatic:true}),
  ]);
  const SCALE = 2.2;
  const BALL_GLOBAL_SCALE = 0.90;
  const LEVEL_TO_R = [12, 16, 22, 30, 40, 54, 72]
          .map(v => Math.round(v * SCALE * BALL_GLOBAL_SCALE));
  const START_LEVEL_MAX = 3;   // 0~3 => 1~4번째 이미지
  const START_R_SCALE = 0.78;  // 작게 만들 비율(원하는 만큼 조절)
  const LEVEL_TO_IMG = [
      'assets/images/ball1.PNG',
      'assets/images/ball2.png',
      'assets/images/ball3.png',
      'assets/images/ball4.png',
      'assets/images/ball5.png',
      'assets/images/ball6.png',
      'assets/images/ball7.png',
    ];
  const LEVEL_TO_IMG_SIZE = [24, 32, 44, 60, 80, 108, 144];
  const EPS = 0;
  let lastSpawnAt = 0;
  let lastGraceAt = 0;
  function spawn(x, level=0, y=20, { byUser=false } = {}){
    lastSpawnAt = Date.now();
    if (byUser) {
      if (lastSpawnAt - lastGraceAt > 600) lastGraceAt = lastSpawnAt;
    }
    const rBase = LEVEL_TO_R[level];
    const r = (level <= START_LEVEL_MAX) ? Math.round(rBase * START_R_SCALE)
            : rBase;
    const img = LEVEL_TO_IMG[level];
    const imgSize = r * 2;
    const BASE = 100;
    const spriteOk = !!img;
    const ball = Bodies.circle(x, y, r, {
      restitution: 0.35,
      friction: 0.02,
      frictionAir: 0.01,
      slop: 0,
      render:{
        ...(spriteOk ? { sprite:{ texture: img, xScale: imgSize / BASE, yScale: imgSize / BASE } }
                : { fillStyle: '#fff' })
      }
    });
    ball.level = level;
    ball.r = r;
    ball.spawnedAt = Date.now();
    World.add(engine.world, ball);
  }

  function clampX(x){ return Math.max(20, Math.min(W-20, x)); }
  function getX(e){
    const t = e.touches?.[0] ?? e;
    const rect = container.getBoundingClientRect();
    const x = (t.clientX - rect.left);
    return clampX(x);
  }

  let isGameOver = false;
  const spawnLock = { locked: false };
  function randInt(min, max){
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  let nextLevel = randInt(0, START_LEVEL_MAX);
  const nextImgEl = document.getElementById('nextBallImg');
  function updateNextUi(){
    if (!nextImgEl) return;
    nextImgEl.src = LEVEL_TO_IMG[nextLevel];
  }
  updateNextUi();
  const onSpawn = (e) => {
    if (spawnLock.locked) return;
    spawn(getX(e), nextLevel, 20, { byUser: true });
    nextLevel = randInt(0, START_LEVEL_MAX);
    updateNextUi();
  };
  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || navigator.maxTouchPoints > 1;
  console.log('isMobile', isMobile)
  if (isMobile) {
    window.addEventListener('touchstart', onSpawn, { passive: true });
  } else {
    window.addEventListener('click', onSpawn, { passive: true });
  }

  const merging = new Set();
  let score = 0;

  Events.on(engine, 'collisionStart', e=>{
    e.pairs.forEach(p=>{
      const a = p.bodyA, b = p.bodyB;
      if(a.level == null || b.level == null) return;
      if(a.level !== b.level) return;


      if(merging.has(a.id) || merging.has(b.id)) return;

      const r = LEVEL_TO_R[a.level];
      const dx = a.position.x - b.position.x;
      const dy = a.position.y - b.position.y;
      const dist = Math.sqrt(dx*dx + dy*dy);

      if(dist > r * 2.2) return;
      const next = a.level + 1;
      if(next >= LEVEL_TO_R.length) return;

      score += (next + 1) * 10;
      document.getElementById('score').innerText = score;

      merging.add(a.id); merging.add(b.id);

      const mx = (a.position.x + b.position.x) / 2;
      const my = (a.position.y + b.position.y) / 2;

      // 제거 → 더 큰 공 생성
      World.remove(engine.world, [a,b]);
      spawn(mx, next, my, { byUser: false });

      // 잠깐 후 잠금 해제
      setTimeout(()=>{ merging.delete(a.id); merging.delete(b.id); }, 0);
    });
  });

  async function preloadImages(list){
    await Promise.all(list.map(src => new Promise(res => {
      const img = new Image();
      img.onload = () => res(true);
      img.onerror = () => res(false);
      img.src = src;
    })));
  }

  const runner = Runner.create();
  (async () => {
    await preloadImages(LEVEL_TO_IMG);
    Runner.run(runner, engine);
    Render.run(render);
  })();

  const GAMEOVER_LINE_Y = 50;
  const GAMEOVER_GRACE_MS = 300;
  const GAMEOVER_HOLD_MS = 320;
  const GAMEOVER_MARGIN = 10;
  const GAMEOVER_STILL_SPEED = 0.45;
  let dangerSince = null;
  const STABLE_SPEED = 0.55;
  const STABLE_DELAY_MS = 500;
  let stableSince = null;
  function isWorldStable(bodies){
    // 공들 중 하나라도 빠르게 움직이면 아직 안정 아님
    for (const b of bodies) {
      if (b.isStatic) continue;
      if (b.level == null) continue;
      if ((b.speed ?? Math.hypot(b.velocity.x, b.velocity.y)) > STABLE_SPEED) return false;
    }
    return true;
  }
  function showGameOver(){
    if(isGameOver) return;
    isGameOver = true;
    spawnLock.locked = true;
    document.getElementById('finalScore').innerText = String(score);
    document.getElementById('gameover').classList.remove('hidden');
    Runner.stop(runner);
  }
  // 매 프레임 체크: 공이 위 라인을 침범하면 게임오버
  Events.on(engine, 'afterUpdate', () => {
    if(isGameOver) return;
    if(Date.now() - lastGraceAt < GAMEOVER_GRACE_MS) return;
    const bodies = Matter.Composite.allBodies(engine.world);
    const now = Date.now();
    const stableNow = isWorldStable(bodies);
    if (!stableNow) {
      stableSince = null;
      dangerSince = null;
      return;
    }
    if (stableSince == null) stableSince = now;
    if (now - stableSince < STABLE_DELAY_MS) {
      dangerSince = null;
      return;
    }
    let isDanger = false;
    for (const b of bodies) {
      if (b.isStatic) continue;
      if (b.level == null) continue; // 공만 체크
      if (b.spawnedAt && (now - b.spawnedAt) < 450) continue;
      const r = b.r ?? (LEVEL_TO_R[b.level] ?? 0);
      const HIT_R_SCALE = 0.65; // 0.55~0.75 사이로 튜닝 추천
      const topY = (b.position.y - r * HIT_R_SCALE);
      const speed = b.speed ?? Math.hypot(b.velocity.x, b.velocity.y);
      if (topY <= (GAMEOVER_LINE_Y - GAMEOVER_MARGIN) && speed < GAMEOVER_STILL_SPEED) {
        isDanger = true;
        break;
      }
    }
    if (!isDanger) {
      dangerSince = null;
      return;
    }

    if (dangerSince == null) dangerSince = Date.now();
    if (Date.now() - dangerSince >= GAMEOVER_HOLD_MS) showGameOver()
  });

  function resetGame(){
    // 월드 비우고(벽/바닥은 다시 깔기)
    Matter.World.clear(engine.world, false);
    Matter.Engine.clear(engine);
    score = 0;
    document.getElementById('score').innerText = '0';
    document.getElementById('gameover').classList.add('hidden');
    isGameOver = false;
    spawnLock.locked = false;
    dangerSince = null;
    stableSince = null;
    World.add(engine.world, [
      // 바닥을 캔버스 안쪽으로 올림
      Bodies.rectangle(
              W/2,
              H - groundMargin + (groundThickness / 2),
              W + 200,
              groundThickness,
              { isStatic: true }
      ),
      // 벽도 바닥 기준으로 살짝 위로 맞춤(안정)
      Bodies.rectangle(-30, (H - groundMargin) / 2, 60, H + 200, {isStatic:true}),
      Bodies.rectangle(W+30, (H - groundMargin) / 2, 60, H + 200, {isStatic:true}),
    ]);
    Runner.run(runner, engine);
  }
  document.getElementById('restartBtn').addEventListener('click', resetGame);


</script>
</body>
</html>
